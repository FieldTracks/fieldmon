/*
This file is part of fieldmon - (C) The Fieldtracks Project

    fieldmon is distributed under the civilian open source license (COSLi).
    Military usage is forbidden.

    You should have received a copy of COLi along with fieldmon.
    If not, please contact info@fieldtracks.org

 */
import {CollectionViewer, DataSource} from '@angular/cdk/collections';
import {StoneInTable} from '../model/stone-in-table';
import {MqttAdapterService} from '../mqtt-adapter.service';
import {BehaviorSubject, interval, Observable, Subscription} from 'rxjs';
import {Observation, StoneEvent} from '../model/StoneEvent';
import {EventEmitter} from '@angular/core';
import {SensorContactTable} from '../model/sensor-contact-table';
import {ageC} from '../helpers/age-helper';
import { IMqttMessage } from 'ngx-mqtt';

export class SensorContactsDs implements DataSource<SensorContactTable> {

  private static contactsSubject: BehaviorSubject<SensorContactTable[]>;
  private static contacts: SensorContactTable [];
  private _subscription: Subscription;
  private _interval: Subscription;

  constructor(private mqttService: MqttAdapterService) {
  }


  connect(collectionViewer: CollectionViewer): Observable<SensorContactTable[]> {
    console.log('Subscribing ...');

    if(SensorContactsDs.contactsSubject === undefined){
      SensorContactsDs.contactsSubject = new BehaviorSubject([]);
      SensorContactsDs.contacts = [];
    }

    this._subscription = this.mqttService.getSubscription('/JellingStone/#', (message: IMqttMessage) => {
      const event: StoneEvent = JSON.parse(message.payload.toString());
      this.updateContacts(event);
    });

    // Update every 5s
    this._interval = interval(5000).subscribe(() => this.emit());
    return SensorContactsDs.contactsSubject;
  }


  disconnect(collectionViewer: CollectionViewer): void {
    console.log("unsubscribing...");
    this._interval.unsubscribe();
    this._subscription.unsubscribe();
  }

  private emit() {
    console.log('Emitting', SensorContactsDs.contacts);
    SensorContactsDs.contactsSubject.next(SensorContactsDs.contacts);
  }

  private updateContacts(stoneEvent: StoneEvent) {
    const stone = `(${stoneEvent.major},${stoneEvent.minor})`;
    const stmp = stoneEvent.timestmp;

    stoneEvent.data.forEach( (obs: Observation) => {
      const contact = new SensorContactTable();
      if (obs.minor) {
        contact.subject = `${obs.major} / ${obs.minor} / ${obs.uuid}`;
      } else {
        contact.subject = `${obs.mac}`;
      }
      contact.rssi = `${obs.min} / ${obs.max} /${obs.avg} / ${obs.remoteRssi}`;
      contact.stone = stone;
      contact.timestmp = stmp;
      SensorContactsDs.contacts.unshift(contact);
      }
    );
  }
}